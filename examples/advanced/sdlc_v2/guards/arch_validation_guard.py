"""
ArchValidationGuard: Runs pytest-arch tests in isolated temp environment.

Validates that implementation passes the architecture tests generated by g_add.
Uses temporary directory to maintain sensing-only principle.
"""

import logging
import subprocess
from pathlib import Path
from typing import Any

from atomicguard.domain.interfaces import GuardInterface
from atomicguard.domain.models import Artifact, GuardResult

from ..models import TestSuite
from .base import TempDirValidationMixin

logger = logging.getLogger("sdlc_checkpoint")


class ArchValidationGuard(GuardInterface, TempDirValidationMixin):
    """
    Runs pytest-arch architecture tests in isolated temp environment.

    This guard is sensing-only: it writes to a temp directory that is
    automatically cleaned up after validation. The actual workdir is
    never modified.

    Requires:
    - g_coder artifact (implementation)
    - g_add artifact (architecture tests)
    """

    def __init__(self, timeout: float = 120.0):
        """
        Initialize the architecture validation guard.

        Args:
            timeout: Timeout in seconds for pytest execution
        """
        self._timeout = timeout

    def validate(self, artifact: Artifact, **deps: Any) -> GuardResult:
        """
        Validate implementation against architecture tests.

        Args:
            artifact: The implementation artifact (from g_coder)
            **deps: Must include 'g_add' artifact containing TestSuite

        Returns:
            GuardResult indicating pass/fail with detailed feedback
        """
        logger.debug("[ArchValidationGuard] Starting architecture validation...")

        # Get the g_add artifact containing architecture tests
        g_add_artifact = deps.get("g_add")
        if g_add_artifact is None:
            return GuardResult(
                passed=False,
                feedback="Missing g_add dependency artifact containing architecture tests",
            )

        # Parse the test suite
        try:
            tests = TestSuite.model_validate_json(g_add_artifact.content)
        except Exception as e:
            return GuardResult(
                passed=False,
                feedback=f"Failed to parse g_add artifact: {e}",
            )

        if not tests.tests:
            return GuardResult(
                passed=True,
                feedback="No architecture tests to run (empty TestSuite)",
            )

        # Run tests in temp directory
        with self._temp_implementation_with_tests(
            artifact.content,
            g_add_artifact.content,
            test_output_path="tests/test_architecture.py",
        ) as tmpdir:
            logger.debug(f"[ArchValidationGuard] Temp dir: {tmpdir}")

            # Run pytest on architecture tests
            passed, output, tests_run, tests_passed = self._run_pytest(tmpdir)

        # Build feedback
        if passed:
            logger.debug("[ArchValidationGuard] âœ“ All architecture tests passed")
            return GuardResult(
                passed=True,
                feedback=f"All {tests_run} architecture tests passed.\n\n```\n{output[:2000]}\n```",
            )
        else:
            logger.debug(
                f"[ArchValidationGuard] âœ— Architecture tests failed: {tests_passed}/{tests_run}"
            )
            return GuardResult(
                passed=False,
                feedback=f"Architecture tests failed: {tests_passed}/{tests_run} passed.\n\n"
                f"Fix the implementation to comply with architecture rules.\n\n"
                f"```\n{output[:3000]}\n```",
            )

    def _run_pytest(self, tmpdir: Path) -> tuple[bool, str, int, int]:
        """
        Run pytest on architecture tests.

        Args:
            tmpdir: Temporary directory containing implementation and tests

        Returns:
            Tuple of (passed, output, tests_run, tests_passed)
        """
        test_file = tmpdir / "tests" / "test_architecture.py"

        if not test_file.exists():
            return False, "Test file not found", 0, 0

        try:
            # Set PYTHONPATH to include the temp directory for imports
            import os

            env = os.environ.copy()
            env["PYTHONPATH"] = str(tmpdir)

            result = subprocess.run(
                [
                    "pytest",
                    str(test_file),
                    "-v",
                    "--tb=short",
                ],
                capture_output=True,
                text=True,
                timeout=self._timeout,
                cwd=tmpdir,
                env=env,
            )

            output = result.stdout + result.stderr
            passed = result.returncode == 0

            # Parse test counts from output
            tests_run, tests_passed = self._parse_test_counts(output)

            return passed, output, tests_run, tests_passed

        except subprocess.TimeoutExpired:
            return False, "pytest timed out", 0, 0
        except FileNotFoundError:
            return False, "pytest not installed", 0, 0
        except Exception as e:
            return False, f"pytest error: {e}", 0, 0

    def _parse_test_counts(self, output: str) -> tuple[int, int]:
        """
        Parse test counts from pytest output.

        Args:
            output: pytest stdout/stderr

        Returns:
            Tuple of (tests_run, tests_passed)
        """
        import re

        # Look for patterns like "5 passed" or "3 passed, 2 failed"
        passed_match = re.search(r"(\d+) passed", output)
        failed_match = re.search(r"(\d+) failed", output)

        passed = int(passed_match.group(1)) if passed_match else 0
        failed = int(failed_match.group(1)) if failed_match else 0

        return passed + failed, passed
