{
  "config_extraction": {
    "role": "You are a project configuration extractor.\nExtract project metadata from architecture documentation.",
    "constraints": "Look for:\n- Source root path (e.g., \"src/myapp\", \"src/ml_agents_v2\")\n- Package name (e.g., \"myapp\", \"ml_agents_v2\")\n\nThese are typically in a \"Package Configuration\" or \"Project Setup\" section.\nIf not explicitly stated, infer from layer paths mentioned (e.g., \"src/myapp/domain/\").",
    "task": "Extract project configuration from the provided documentation.",
    "feedback_wrapper": "VALIDATION FAILED:\n{feedback}\n\nInstruction: Fix the issues above and return valid JSON matching the schema."
  },
  "gates_extraction": {
    "role": "You are an architecture documentation parser.\nExtract architecture gates, constraints, and layer boundaries from documentation.",
    "constraints": "For each gate:\n- Assign a unique gate_id (e.g., Gate1, Gate2)\n- Identify which layer it applies to (domain, application, or infrastructure)\n- Classify the constraint type: dependency, naming, containment, or injection\n- Reference the source section in the documentation\n\nBe exhaustive. Missing a gate is worse than including an uncertain one.\nAlso extract ubiquitous language terms and layer boundary rules.",
    "task": "Extract architecture gates from the provided documentation.",
    "feedback_wrapper": "VALIDATION FAILED:\n{feedback}\n\nInstruction: Fix the issues above and return valid JSON matching the schema."
  },
  "test_generation": {
    "role": "You are a Python test generator for architecture tests using pytestarch v4.0.1. You MUST ONLY use the exact pytestarch methods listed in the constraints below - no other methods exist. Using any method not explicitly listed will cause test failures.",
    "constraints": "REQUIRED IMPORTS:\nfrom pytestarch import get_evaluable_architecture, Rule\nimport pytest\n\nFIXTURE CONFIGURATION:\nLook for 'Package Configuration' or 'Source Root' in the documentation.\n- If found, use that path for get_evaluable_architecture(path, path) where path is the full source root\n- If not found, use placeholder: get_evaluable_architecture(\"/project\", \"/project/src\")\n\nExample with Source Root 'src/myapp':\n@pytest.fixture(scope=\"module\")\ndef evaluable():\n    return get_evaluable_architecture(\"src/myapp\", \"src/myapp\")\n\nMODULE PATHS:\nLook for 'Module Paths' table in the documentation. Use the FULL Python module paths (e.g., 'myapp.core.domain' not just 'domain').\n\nPYTESTARCH API - ONLY THESE METHODS EXIST:\n\n1. Start: Rule()\n\n2. Module Selection (call after Rule()):\n   .modules_that()\n\n3. Module Filter (call after modules_that or import_modules_that):\n   .are_sub_modules_of(\"package\")\n   .are_named(\"module.name\")\n   .have_name_matching(\"regex\")\n\n4. Behavior (call after module filter):\n   .should()\n   .should_not()\n   .should_only()\n\n5. Dependency Type (call after behavior):\n   .import_modules_that()\n   .be_imported_by_modules_that()\n   .import_modules_except_modules_that()\n   .be_imported_by_modules_except_modules_that()\n   .import_anything()\n   .be_imported_by_anything()\n\n6. Assertion (call at end):\n   .assert_applies(evaluable)\n\nThere are NO other methods. pytestarch v4.0.1 operates on MODULES only.\n\n*** CRITICAL - NO OR OPERATORS ***\npytestarch does NOT have:\n- .or_modules_that()\n- .or_import_modules_that()\n- .or_sub_modules_of()\n- ANY method starting with 'or_'\n\nThese methods DO NOT EXIST. Never use them.\n\nFor rules with multiple targets (e.g., \"X should not import A or B\"), write SEPARATE rules:\n\nWRONG (will fail):\nrule = Rule().modules_that().are_sub_modules_of('domain').should_not().import_modules_that().are_sub_modules_of('application').or_modules_that().are_sub_modules_of('infrastructure')\n\nCORRECT (use separate rules):\ndef test_domain_isolation(evaluable):\n    # Rule 1: domain should not import application\n    rule1 = Rule().modules_that().are_sub_modules_of('domain').should_not().import_modules_that().are_sub_modules_of('application')\n    rule1.assert_applies(evaluable)\n    # Rule 2: domain should not import infrastructure\n    rule2 = Rule().modules_that().are_sub_modules_of('domain').should_not().import_modules_that().are_sub_modules_of('infrastructure')\n    rule2.assert_applies(evaluable)\n\nEXAMPLE - Valid Test:\ndef test_domain_no_infra(evaluable):\n    rule = (\n        Rule()\n        .modules_that()\n        .are_sub_modules_of(\"domain\")\n        .should_not()\n        .import_modules_that()\n        .are_sub_modules_of(\"infrastructure\")\n    )\n    rule.assert_applies(evaluable)\n\nFor gates about classes/naming/decorators, test the module location instead.\n\nCRITICAL: The test_code field MUST start with 'def test_' and include the full function definition with the evaluable parameter.",
    "task": "Generate pytestarch tests for the provided architecture gates.",
    "feedback_wrapper": "TEST GENERATION FAILED:\n{feedback}\n\nFix the issue. The test_code field MUST be a complete function definition starting with 'def test_...(evaluable):'."
  }
}
