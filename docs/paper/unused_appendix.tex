\appendix


% =============================================================================
% APPENDIX A: THE UNIFIED HIERARCHY OF SEARCH & COMPLEXITY
% =============================================================================
\section{The Unified Hierarchy of Search \& Complexity}
\label{app:unified_search}

This appendix unifies the definitions of the agent's operating environment with the principle of "Conservation of Complexity," establishing the formal relationship between human design effort and agentic runtime autonomy.

% -----------------------------------------------------------------------------
% 1. THE SPACES (THE TERRITORY)
% -----------------------------------------------------------------------------
\subsection{The Hierarchy of Spaces}
We first establish the formal "terrain" in which the agent operates.

\subsubsection{The Problem Space (The Abstract Goal)}
\begin{itemize}
    \item \textbf{Definition:} The abstract boundary of requirements, independent of implementation. It defines ``what we want'' rather than ``how to get it.''
    \item \textbf{Content:} Constraints, customer needs, and goal definitions.
    \item \textbf{Example:} In an 8-Puzzle, the problem space is simply ``Arrange tiles 1-8 in order,'' without specifying the mechanics of movement.
\end{itemize}

\subsubsection{The State Space (The Mathematical Territory)}
\begin{itemize}
    \item \textbf{Definition:} The set of all possible configurations the system can theoretically occupy.
    \item \textbf{Formal Definition:} A directed graph $G = (V, E)$ where:
    \begin{itemize}
        \item $V$ (Nodes): Every possible configuration (e.g., all $9!/2$ tile arrangements).
        \item $E$ (Edges): All physically valid transitions (e.g., Up, Down, Left, Right).
    \end{itemize}
    \item \textbf{Note:} This space exists as a mathematical fact, regardless of whether an agent observes or explores it.
\end{itemize}

\subsubsection{The Solution Space (The Valid Paths)}
\begin{itemize}
    \item \textbf{Definition:} The subset of paths within the State Space that successfully connect the Initial State ($S_0$) to the Goal State ($G$).
    \item \textbf{Formal Definition:} A set of action sequences $A = \{a_1, a_2, \dots, a_n\}$ such that the transition function $T(S_0, A) = G$.
    \item \textbf{Characteristics:} Contains both optimal solutions (shortest paths) and suboptimal solutions (looping or inefficient paths).
\end{itemize}

% -----------------------------------------------------------------------------
% 2. THE STRATEGY (METHODS)
% -----------------------------------------------------------------------------
\subsection{Solution/Search Methods (The Strategy)}
This section categorizes the fundamental approaches used to navigate from the Problem Space through the State Space.

\begin{itemize}
    \item \textbf{Knowledge Engineering (Human-Designed Solutions)}
    \begin{itemize}
        \item \textit{Concept:} Direct encoding of domain expertise into rules and structures (Safety as a constraint).
        \item \textit{Examples:} Expert systems, rule-based systems, knowledge graphs.
    \end{itemize}

    \item \textbf{Search-Based Methods (Algorithm-Discovered Solutions)}
    \begin{itemize}
        \item \textit{Systematic Search:} Uninformed (BFS, DFS, Uniform Cost) and Informed (A*, IDA*) traversal.
        \item \textit{Local Search \& Metaheuristics:} Optimization (Hill Climbing, Simulated Annealing, Genetic Algorithms).
        \item \textit{Adversarial Search:} Strategies for multi-agent environments (Minimax, MCTS).
    \end{itemize}

    \item \textbf{Constraint Satisfaction Methods}
    \begin{itemize}
        \item \textit{Concept:} Finding states that satisfy a set of constraints rather than finding a path.
        \item \textit{Examples:} Backtracking with propagation, Arc consistency, Min-conflicts.
    \end{itemize}

    \item \textbf{Logic-Based Methods (Inference \& Reasoning)}
    \begin{itemize}
        \item \textit{Concept:} Using formal logic to deduce action sequences.
        \item \textit{Examples:} SAT solvers, First-order logic (Resolution), Classical Planning (STRIPS, PDDL).
    \end{itemize}

    \item \textbf{Probabilistic Methods (Reasoning Under Uncertainty)}
    \begin{itemize}
        \item \textit{Concept:} Handling states where outcomes are stochastic or partially observable.
        \item \textit{Examples:} Bayesian Networks, MDPs, Kalman filters.
    \end{itemize}

    \item \textbf{Learning-Based Methods (Experience-Driven)}
    \begin{itemize}
        \item \textit{Concept:} Approximating the solution function through data and reward signals.
        \item \textit{Examples:} Reinforcement Learning (Q-learning), Supervised Learning, Neural Search.
    \end{itemize}

    \item \textbf{Neuro-Symbolic Methods (Hybrid Approaches)}
    \begin{itemize}
        \item \textit{Concept:} Integrating rational, deterministic logic with stochastic, generative capabilities.
        \item \textbf{Implementation: The Dual-State Framework}
        \begin{itemize}
            \item \textit{Mechanism:} Uses \textbf{Atomic Action Pairs} (Generate + Verify) to project opaque outputs onto a deterministic state.
            \item \textit{Property:} Achieves \textbf{Bounded Indeterminacy}â€”the content of an action is stochastic, but its validity is strictly bounded by deterministic guards.
            \item \textit{Role:} Bridges the ``Rational Agent'' (Symbolic/Logic) and the ``Stochastic Generator'' (Learning/Probabilistic).
        \end{itemize}
    \end{itemize}
\end{itemize}

% -----------------------------------------------------------------------------
% 3. THE TIME (LOCUS OF DISCOVERY)
% -----------------------------------------------------------------------------
\subsection{The Locus of Solution Discovery (Time of Learning)}
This dimension categorizes \textit{when} the solution is encoded into the agent.

\begin{itemize}
    \item \textbf{Training Time (Pre-Computation):}
    \begin{itemize}
        \item \textit{Definition:} The solution strategy is learned offline and frozen into the model weights or rule set.
        \item \textit{Examples:} Supervised Learning, Pre-trained LLMs, Static Expert Systems.
    \end{itemize}

    \item \textbf{Test Time (Computation / Inference):}
    \begin{itemize}
        \item \textit{Definition:} The solution is discovered dynamically during execution via reasoning or search.
        \item \textit{Examples:} A* Search, Chain-of-Thought (CoT), Constraint Solving.
    \end{itemize}

    \item \textbf{Continuous Learning (Runtime Adaptation):}
    \begin{itemize}
        \item \textit{Definition:} The agent updates its policy \textit{during} execution based on environmental feedback.
        \item \textbf{Paper Contribution:} The Dual-State Framework enables this via the \textbf{Optimization Loop} (Section 6.1), orchestrating three distinct roles:
        \begin{itemize}
            \item \textbf{The Coach ($H_{prob}$):} Analyzes feedback to propose immediate context refinements (Liveness).
            \item \textbf{The Critic:} Uses deterministic Guard failures as a sparse reward signal (Safety).
            \item \textbf{The Update:} Distills successful traces back into the generator to minimize future retries (Optimization).
        \end{itemize}
    \end{itemize}
\end{itemize}


% -----------------------------------------------------------------------------
% 4. THE CONSERVATION OF SEARCH (THE MECHANISM)
% -----------------------------------------------------------------------------
\subsection{The Conservation of Search}
We postulate a ``Conservation of Complexity,'' where the burden of search is not eliminated but shifted between the Human (Design Time) and the Agent (Runtime).

\subsubsection{The Locus of Search Matrix}
We stratify problem-solving strategies based on \textit{who} performs the search and \textit{when} it occurs.

\begin{table}[h]
\centering
\small
\renewcommand{\arraystretch}{1.5}
\newcolumntype{S}{>{\hsize=.6\hsize\raggedright\arraybackslash}X}
\newcolumntype{C}{>{\hsize=1.13\hsize\raggedright\arraybackslash}X}

\begin{tabularx}{\textwidth}{@{} S C C C @{}}
\toprule
\textbf{Strategy} &
\textbf{Layer 1: Logic/Goal Search (Macro)} &
\textbf{Layer 2: Implementation Search (Micro)} &
\textbf{Nature of System} \\
\midrule

\textbf{Traditional Software (Deterministic)} &
\textbf{Human (Offline).} Hard-coded logic defines the exact path and transitions. &
\textbf{Human (Offline).} Hard-coded implementation defines artifacts (code/data). &
\textbf{Fully Deterministic.} No runtime search; executes a fixed trajectory. \\ \addlinespace[1em]

\textbf{Pure Search-Based AI (e.g., MCTS)} &
\textbf{Agent (Runtime).} Discovers the path to the goal via exploration. &
\textbf{Agent (Runtime).} Discovers valid moves via simulation. &
\textbf{Fully Dynamic.} Double runtime search burden; requires complete world model. \\ \addlinespace[1em]

\textbf{Guarded Generative AI (This Work)} &
\textbf{Human (Offline).} Defines Guards and Topology ($\mathcal{S}_{workflow}$). &
\textbf{Agent (Runtime).} Hunts for valid artifacts via generation ($\mathcal{S}_{env}$). &
\textbf{Hybrid.} Bounded Indeterminacy (Human Goals, Machine Implementation). \\
\bottomrule
\end{tabularx}
\caption{The Locus of Search Matrix. This compares our Dual-State framework against Traditional Software and Pure Search AI.}
\label{tab:locus_search}
\end{table}

\subsubsection{Sources of Search Space Reduction}
Different strategies utilize distinct mechanisms to collapse the runtime Search Space.

\begin{itemize}
    \item \textbf{Heuristics (e.g., A*):} Uses mathematical estimation ($f = g + h$) to guide search. \textit{Trade-off:} Heuristics may be flawed or computationally expensive.
    \item \textbf{Learning (e.g., RL):} Uses statistical convergence ($\pi$) to ``remember'' obstacles. \textit{Trade-off:} High training cost and opacity (``Black Box'').
    \item \textbf{Guards (This Framework):} Uses \textbf{Logic Injection}.
    \begin{itemize}
        \item \textit{Mechanism:} The Human's Design-Time Search acts as a \textbf{Bounding Box}. The agent does not search the \textit{entire} universe of text; it searches only the small neighborhood of ``Artifacts that satisfy Guard A''.
    \end{itemize}
\end{itemize}

% -----------------------------------------------------------------------------
% 5. THE SEARCH SPACE (THE RESULT)
% -----------------------------------------------------------------------------
\subsection{The Search Space (The Flashlight Beam)}
Finally, we define the efficiency of the system by the actual area explored.

\begin{itemize}
    \item \textbf{Definition:} The specific subset of the State Space strictly visited by the algorithm.
    \item \textbf{The Generative Challenge:} In standard GenAI, the search occurs in the effectively infinite \textit{Environment Space} ($\mathcal{S}_{env}$). The ``flashlight beam'' is diffused, illuminating invalid syntax and hallucinations.
    \item \textbf{The Dual-State Solution (Projection):}
    By defining the Guards (Human Offline Search), we \textbf{project} execution onto the finite \textit{Workflow Space} ($\mathcal{S}_{workflow}$).
    \begin{itemize}
        \item When a Guard fails ($v = \perp$), the Context updates but the Workflow State remains invariant.
        \item This effectively ``prunes'' invalid generative branches before they become nodes in the search tree, collapsing search complexity from infinite to linear/polynomial relative to workflow length.
    \end{itemize}
\end{itemize}

\newpage

% =============================================================================
% APPENDIX B: MAPPING SDLC CONSTRAINTS TO HIERARCHICAL GUARDS
% =============================================================================
\section{Mapping SDLC Constraints to Hierarchical Guards}
\label{app:sdlc_mapping}

This appendix demonstrates how a rigid \textbf{Software Development Life Cycle (SDLC)} is mapped to the \textbf{Workflow Topology} of a Neuro-Symbolic Agent. The agent functions as a hierarchical inference engine: it evaluates high-level predicates to determine if the Environment State is valid. If a predicate evaluates to \texttt{FALSE}, it triggers specific Atomic Action Pairs to satisfy the guard.

\subsection{1. The Guard Hierarchy (The Invariants)}
We define the ``Architecture Validation Agent'' through a sequence of boolean predicates that serve as the gating functions for the workflow. Transitions between states are valid if and only if the corresponding Guard Function returns \texttt{TRUE}.

\begin{description}
    \item[\textbf{$\mathbf{G_4}$: Design Phase Integrity}] \hfill \\
    Transitions from \texttt{ACL\_INTERFACES\_DEFINED} to \newline \texttt{INFRASTRUCTURE\_ABSTRACTIONS\_DEFINED}.
    \begin{equation}
    \begin{split}
        G_4 = \ & \texttt{acl\_interfaces\_exist} \\
              \land \ & \texttt{factory\_interfaces\_in\_domain} \\
              \land \ & \texttt{no\_infrastructure\_types\_in\_domain}
    \end{split}
    \end{equation}

    \item[\textbf{$\mathbf{G_5}$: Dependency Injection Design}] \hfill \\
    Transitions from \texttt{INFRASTRUCTURE\_ABSTRACTIONS\_DEFINED} to \newline \texttt{DI\_DESIGNED}.
    \begin{equation}
    \begin{split}
        G_5 = \ & \texttt{factory\_names\_match\_purpose} \\
              \land \ & \texttt{container\_configuration\_specified} \\
              \land \ & \texttt{no\_concrete\_implementations\_registered}
    \end{split}
    \end{equation}

    \item[\textbf{$\mathbf{G_{10}}$: Implementation Quality Gates}] \hfill \\
    Transitions from \texttt{QUALITY\_GATES\_PASSING} to \newline \texttt{IMPLEMENTATION\_PHASE}.
    \begin{equation}
    \begin{split}
        G_{10} = \ & \texttt{domain\_never\_imports\_infrastructure} \\
               \land \ & \texttt{container\_injects\_abstractions\_only} \\
               \land \ & \texttt{factories\_return\_domain\_interfaces} \\
               \land \ & \texttt{no\_hard\_coded\_providers} \\
               \land \ & \texttt{all\_dependencies\_mockable}
    \end{split}
    \end{equation}

    \item[\textbf{$\mathbf{G_{20}}$: Validation Phase Completion}] \hfill \\
    Transitions from \texttt{IMPLEMENTATION\_PHASE} to \texttt{VALIDATION\_PHASE}.
    \begin{equation}
    \begin{split}
        G_{20} = \ & \texttt{bdd\_scenarios\_defined} \\
               \land \ & \texttt{tests\_failing} \ (\text{initial state}) \\
               \land \ & \texttt{tests\_passing} \ (\text{final state}) \\
               \land \ & \texttt{quality\_gates\_passing}
    \end{split}
    \end{equation}
\end{description}

\subsection{2. Compilation to Atomic Action Pairs}
The agent's execution loop consists of inferring the value of these predicates. If $G_x(s_{env})$ is \texttt{TRUE}, the agent proceeds. If \texttt{FALSE}, it executes the corresponding generator.

Below is the DS-PDDL definition for the action required to satisfy \textbf{$G_4$}. Note how the SDLC constraint (the Guard) explicitly bounds the generative output (the Action).

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Lisp, caption={DS-PDDL Action to satisfy Guard $G_4$.}, basicstyle=\ttfamily\small, frame=single, mathescape=true]
(:generative-action define-infrastructure-abstractions
    :parameters (?ctx - bounded-context)

    ;; 1. Precondition: The previous state in the SDLC must be valid.
    :precondition (acl-interfaces-defined ?ctx)

    ;; 2. Generator: The stochastic attempt to produce code
    ;;    that satisfies the architectural constraints.
    :generator (call-llm "gen_infra_abstractions" ?ctx)

    ;; 3. Guard ($G_4$): The deterministic definition of success.
    ;;    The agent loops here until this specific predicate is TRUE.
    :guard (
        :sense (and
            (check-acl-interfaces-exist ?ctx)
            (check-factory-interfaces-domain ?ctx)
            (check-no-infra-types-in-domain ?ctx)
        )
        :pass  (infrastructure-abstractions-defined ?ctx)
        :fail  (acl-interfaces-defined ?ctx) ;; Refinement Loop
    )
)
\end{lstlisting}
\end{minipage}

\newpage
\section{Experimental Harness (simulation.py)}
\label{app:simulation_code}

To ensure reproducibility, we provide the full implementation of the experimental harness. This script includes the exact prompts used for the Diagnostic Probes and the implementation of the \textbf{Guard Functions} ($G_{syntax}$, $G_{test}$) that drive the refinement loop.

The implementation highlights the \textbf{Diagnostic Feedback} mechanism (see \texttt{\_get\_template\_guidance} and the failure messages in \texttt{\_check\_password}). These return specific, deterministic error traces to the generator, acting as a ``Loud Guardian'' that provides a gradient for correction without requiring a separate coaching agent.

\begin{lstlisting}[language=Python, caption={The Python simulation harness implementing the Dual-State Control Loop.}, basicstyle=\ttfamily\scriptsize, breaklines=true, numbers=left, stepnumber=5]
import ast
import contextlib
import csv
import io
import logging
import multiprocessing
import os
import re
import sqlite3
from queue import Queue
import time
from dataclasses import dataclass
from typing import Iterator
import click
from rich.console import Console
from rich.logging import RichHandler
from rich.progress import (
    BarColumn, Progress, SpinnerColumn, TaskProgressColumn, TextColumn, TimeRemainingColumn
)
from rich.table import Table
from openai import OpenAI

# --- Configuration ---
NUM_TRIALS = 100
TOKEN_COST_PER_TRY = 1.0
TRIAL_TIMEOUT_SECONDS = 180
CIRCUIT_BREAKER_THRESHOLD = 5

TASK_PROMPTS = {
    "password": """Write a Python function `validate_password(password)` that checks if a password meets the following criteria:
1. Length between 12 and 32 characters.
2. Contains at least one uppercase letter, one lowercase letter, one digit, and one special character from !@#$%^&*.
3. No character can appear more than 2 times in the password.
4. Must NOT contain any sequence of 3 consecutive characters from the alphabet (case-insensitive, e.g., "abc", "CDe", "xyz" are invalid).
5. The sum of all digits in the password must be a prime number.
Returns True if valid, False otherwise.""",
    "lru": """Write a Python class `LRUCache` with the following specifications:
1. `__init__(self, capacity: int)`: Initializes the cache with a positive capacity.
2. `get(self, key: int) -> int`: Return the value of the key if it exists, otherwise return -1.
3. `put(self, key: int, value: int) -> None`: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
4. The functions `get` and `put` must each run in O(1) average time complexity.
""",
    "template": """Write a Python function `render_template(template: str, context: dict) -> str` that implements a simple template engine:
1. Replace `{{ variable }}` with the value from context dict. If the variable is not in context, leave the placeholder unchanged.
2. Support basic conditionals: `{% if variable %}text{% endif %}`. If variable exists in context and is truthy, include the text. Otherwise, remove the entire block.
3. You can use regex for matching patterns.
"""
}

# --- Artifact Definition ---
@dataclass
class CodeArtifact:
    code: str
    extraction_method: str = "unknown"

# --- The Generator ---
class OllamaGenerator:
    def __init__(self, model: str, base_url: str) -> None:
        self.model = model
        self.client = OpenAI(base_url=base_url, api_key="ollama", timeout=120.0)

    def generate(self, prompt: str) -> CodeArtifact:
        try:
            messages=[
                {"role": "system", "content": "You are a helpful Python programming assistant. Your task is to provide a complete, runnable Python code solution. Always enclose the Python code in a single markdown block."},
                {"role": "user", "content": prompt}
            ]
            response = self.client.chat.completions.create(
                model=self.model, messages=messages, temperature=0.7
            )
            content = response.choices[0].message.content

            # Extraction Logic
            match = re.search(r"```python\n(.*?)\n```", content, re.DOTALL)
            if match: return CodeArtifact(code=match.group(1), extraction_method="python_block")
            match = re.search(r"```\n(.*?)\n```", content, re.DOTALL)
            if match: return CodeArtifact(code=match.group(1), extraction_method="generic_block")
            return CodeArtifact(code=content, extraction_method="full_content")
        except Exception:
            return CodeArtifact(code="", extraction_method="error")

# --- The Guards ---
class Guard:
    def check(self, artifact: CodeArtifact) -> tuple[bool, str]:
        raise NotImplementedError

class SyntaxGuard(Guard):
    def check(self, artifact: CodeArtifact) -> tuple[bool, str]:
        try:
            ast.parse(artifact.code)
            return True, ""
        except SyntaxError as e:
            return False, f"{e}"

class TestGuard(Guard):
    def __init__(self, task_name: str) -> None:
        self.task_name = task_name

    def check(self, artifact: CodeArtifact) -> tuple[bool, str]:
        # Execution is isolated in a separate process with timeout
        q = multiprocessing.Queue()
        p = multiprocessing.Process(target=self._execute_and_check, args=(artifact, q))
        p.start()
        p.join(60)
        if p.is_alive():
            p.terminate()
            return False, "Timeout: Code execution exceeded 60s limit."
        return q.get()

    def _execute_and_check(self, artifact: CodeArtifact, q: Queue) -> None:
        try:
            local_scope = {"__builtins__": __builtins__}
            exec(artifact.code, local_scope)
            if self.task_name == "password":
                q.put(self._check_password(local_scope))
            elif self.task_name == "lru":
                q.put(self._check_lru(local_scope))
            elif self.task_name == "template":
                q.put(self._check_template(local_scope))
        except Exception as e:
            q.put((False, f"Runtime Error: {e}"))

    def _check_password(self, scope: dict) -> tuple[bool, str]:
        if 'validate_password' not in scope: return False, "Function not found"
        func = scope['validate_password']
        tests = [
            ("Valid1@34abc", False), # Sequence abc
            ("Valid1@34", False), # Too short
            ("A!bX2579qW@#", True), # Valid: Prime sum (23), unique chars
            ("A!b222222", False), # Sum=12 (not prime), >2 '2's
            ("A!b12", False), # Sum=3 (prime), but short
        ]
        for pwd, expected in tests:
            if func(pwd) != expected:
                return False, f"Test Failed: input='{pwd}', expected={expected}"
        return True, ""

    def _check_lru(self, scope: dict) -> tuple[bool, str]:
        if 'LRUCache' not in scope: return False, "Class not found"
        LRUCache = scope['LRUCache']

        # Test 1: Capacity & Eviction
        cache = LRUCache(2)
        cache.put(1, 1); cache.put(2, 2)
        cache.put(3, 3) # Should evict
        if cache.get(2) == -1 and cache.get(1) != -1:
             # Depending on implementation, either 1 (LRU) or 2 (MRU?) might be evicted.
             # This test enforces a specific invariant.
             pass

        # Test 3: Recency Update
        cache = LRUCache(2)
        cache.put(1, 1); cache.put(2, 2)
        cache.get(1) # 1 is now MRU
        cache.put(3, 3) # Should evict 2 (LRU)
        if cache.get(2) != -1: return False, "Key 2 should be evicted (recency check)"
        if cache.get(1) != 1: return False, "Key 1 should exist"
        return True, ""

    def _check_template(self, scope: dict) -> tuple[bool, str]:
        if 'render_template' not in scope: return False, "Function not found"
        func = scope['render_template']
        # Simplified tests for variables and basic conditionals
        tests = [
            ("Hello {{ name }}!", {"name": "World"}, "Hello World!", "variable_substitution"),
            ("{% if show %}Visible{% endif %}", {"show": True}, "Visible", "conditional_true"),
            ("{% if show %}Hidden{% endif %}", {"show": False}, "", "conditional_false"),
        ]
        failed_constraints = set()

        for tmpl, ctx, expected, constraint in tests:
            if func(tmpl, ctx) != expected:
                failed_constraints.add(constraint)

        if failed_constraints:
            # Provide diagnostic guidance (NOT coaching, just specific error info)
            return False, self._get_template_guidance(failed_constraints)
        return True, ""

    def _get_template_guidance(self, failed_constraints: set[str]) -> str:
        guidance_map = {
            "variable_substitution": "Hint: Use regex to find {{ variable }} patterns.",
            "conditional_true": "Hint: Check regex for {% if variable %}...{% endif %} blocks.",
            "conditional_false": "Hint: Ensure falsy/missing values remove the block entirely.",
        }
        hints = [guidance_map[c] for c in failed_constraints if c in guidance_map]
        return "Test failures detected. " + " ".join(hints)

# --- The Workflow ---
def run_guarded_workflow(generator, prompt, guards, r_max):
    retries = 0
    feedback_history = []

    while retries <= r_max:
        # Augment prompt with feedback
        current_prompt = prompt
        if feedback_history:
            current_prompt += "\n\nPREVIOUS FAILURES:\n" + "\n".join(feedback_history)

        artifact = generator.generate(current_prompt)

        # Guard Check
        all_passed = True
        for guard in guards:
            success, msg = guard.check(artifact)
            if not success:
                # Store unique feedback
                if msg not in feedback_history:
                    feedback_history.append(msg)
                all_passed = False
                break

        if all_passed: return True, retries
        retries += 1

    return False, retries
\end{lstlisting}
